<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="shortcut icon" type="image/png" href="https://github.com/renzholy.png?size=128"/><title>WASM 输入与输出</title><meta name="author" content="renzholy"/><meta name="date" content="2022-06-26"/><meta name="application-name" content="WASM 输入与输出"/><meta name="description" content="## WASM 简介

WASM（WebAssembly）是一种用于堆栈式虚拟机的二进制指令格式。它是是一种文件格式标准，不是特定的虚拟机实现，因此有各种 compiler、interpreter 以及 runtime，如[wastime](https://github.com/bytecodealliance/wasmtime)、[Wasmer](https://wasmer.io/)、[V8](https://v8.dev/docs/wasm-compilation-pipeline)、 [Luc..."/><meta name="theme-color" content="#24292e"/><meta property="og:url" content="https://fpt.ink/wasm/输入与输出"/><meta property="og:type" content="blog"/><meta property="og:title" content="WASM 输入与输出"/><meta property="og:site_name" content="Found Pan Tiger"/><meta property="og:description" content="## WASM 简介

WASM（WebAssembly）是一种用于堆栈式虚拟机的二进制指令格式。它是是一种文件格式标准，不是特定的虚拟机实现，因此有各种 compiler、interpreter 以及 runtime，如[wastime](https://github.com/bytecodealliance/wasmtime)、[Wasmer](https://wasmer.io/)、[V8](https://v8.dev/docs/wasm-compilation-pipeline)、 [Luc..."/><meta name="twitter:card" content="summary"/><meta name="twitter:domain" content="fpt.ink"/><meta name="twitter:url" content="https://fpt.ink/wasm/输入与输出"/><meta name="twitter:title" content="WASM 输入与输出"/><meta name="twitter:description" content="## WASM 简介

WASM（WebAssembly）是一种用于堆栈式虚拟机的二进制指令格式。它是是一种文件格式标准，不是特定的虚拟机实现，因此有各种 compiler、interpreter 以及 runtime，如[wastime](https://github.com/bytecodealliance/wasmtime)、[Wasmer](https://wasmer.io/)、[V8](https://v8.dev/docs/wasm-compilation-pipeline)、 [Luc..."/><meta name="next-head-count" content="19"/><link rel="preload" href="/_next/static/css/52f378189a8709f9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/52f378189a8709f9.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-962449b389de7a23.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-619fc981483afe9e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-ce056a74a3cd3589.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/827-c7415ccd8033e3a7.js" defer=""></script><script src="/_next/static/chunks/pages/%5B%5B...path%5D%5D-7f16f7784066193c.js" defer=""></script><script src="/_next/static/XvQqgVKXZyTL6GdtsbpHY/_buildManifest.js" defer=""></script><script src="/_next/static/XvQqgVKXZyTL6GdtsbpHY/_ssgManifest.js" defer=""></script><script src="/_next/static/XvQqgVKXZyTL6GdtsbpHY/_middlewareManifest.js" defer=""></script><style data-emotion="css 1uruf9f 35tm3r 82a6rk atf797 15sbtt4 hv4a7g 11sb6mr">::-webkit-scrollbar{display:none;}body{margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji;}:root{--max-width:900px;}.css-35tm3r{position:fixed;top:0;left:0;right:0;height:64px;background-color:#24292e;padding:0 20px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.css-35tm3r a{color:#ffffff;font-size:14px;font-weight:600;-webkit-text-decoration:none;text-decoration:none;}.css-35tm3r a+a{margin-left:16px;}.css-35tm3r a:hover,.css-35tm3r a:focus{color:hsla(0, 0%, 100%, 0.7);}.css-82a6rk{-webkit-flex:1;-ms-flex:1;flex:1;}.css-atf797{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;height:64px;padding:0 20px;border-top:1px solid #e1e4e8;}.css-atf797 span{color:#586069;font-size:12px;}.css-atf797 a{color:#0366d6;-webkit-text-decoration:none;text-decoration:none;font-size:12px;}.css-atf797 a+a{margin-left:16px;}.css-atf797 a:hover,.css-atf797 a:focus{-webkit-text-decoration:underline;text-decoration:underline;}.css-15sbtt4{margin:16px auto;padding:0 20px;max-width:var(--max-width);font-size:14px;color:#6a737d;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:end;-ms-flex-pack:end;-webkit-justify-content:flex-end;justify-content:flex-end;}.css-hv4a7g{margin:96px auto 32px;max-width:var(--max-width);min-height:calc(
            100vh - 96px - 2 * 64px - 2px - 302px
          );}.css-hv4a7g h1>a:nth-child(1),.css-hv4a7g h2>a:nth-child(1),.css-hv4a7g h3>a:nth-child(1),.css-hv4a7g h4>a:nth-child(1),.css-hv4a7g h5>a:nth-child(1),.css-hv4a7g h6>a:nth-child(1){float:left;line-height:1;margin-left:-20px;padding-right:4px;}.css-hv4a7g h1>a:nth-child(1):focus,.css-hv4a7g h2>a:nth-child(1):focus,.css-hv4a7g h3>a:nth-child(1):focus,.css-hv4a7g h4>a:nth-child(1):focus,.css-hv4a7g h5>a:nth-child(1):focus,.css-hv4a7g h6>a:nth-child(1):focus{outline:none;}.css-hv4a7g h1>a:nth-child(1)>span,.css-hv4a7g h2>a:nth-child(1)>span,.css-hv4a7g h3>a:nth-child(1)>span,.css-hv4a7g h4>a:nth-child(1)>span,.css-hv4a7g h5>a:nth-child(1)>span,.css-hv4a7g h6>a:nth-child(1)>span{color:#1b1f23;vertical-align:middle;visibility:hidden;display:inline-block;fill:currentColor;vertical-align:text-bottom;}.css-hv4a7g h1:hover>a:nth-child(1),.css-hv4a7g h2:hover>a:nth-child(1),.css-hv4a7g h3:hover>a:nth-child(1),.css-hv4a7g h4:hover>a:nth-child(1),.css-hv4a7g h5:hover>a:nth-child(1),.css-hv4a7g h6:hover>a:nth-child(1){-webkit-text-decoration:none;text-decoration:none;}.css-hv4a7g h1:hover>a:nth-child(1)>span,.css-hv4a7g h2:hover>a:nth-child(1)>span,.css-hv4a7g h3:hover>a:nth-child(1)>span,.css-hv4a7g h4:hover>a:nth-child(1)>span,.css-hv4a7g h5:hover>a:nth-child(1)>span,.css-hv4a7g h6:hover>a:nth-child(1)>span{visibility:visible;}.css-hv4a7g h1:hover>a:nth-child(1)>span:before,.css-hv4a7g h2:hover>a:nth-child(1)>span:before,.css-hv4a7g h3:hover>a:nth-child(1)>span:before,.css-hv4a7g h4:hover>a:nth-child(1)>span:before,.css-hv4a7g h5:hover>a:nth-child(1)>span:before,.css-hv4a7g h6:hover>a:nth-child(1)>span:before{width:16px;height:16px;content:' ';display:inline-block;background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' width='16' height='16' aria-hidden='true'%3E%3Cpath fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'%3E%3C/path%3E%3C/svg%3E");}.css-hv4a7g{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;line-height:1.5;color:#24292e;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji;font-size:16px;line-height:1.5;word-wrap:break-word;padding:0 20px;}.css-hv4a7g details{display:block;}.css-hv4a7g summary{display:-webkit-box;display:-webkit-list-item;display:-ms-list-itembox;display:list-item;}.css-hv4a7g a{background-color:initial;}.css-hv4a7g a:active,.css-hv4a7g a:hover{outline-width:0;}.css-hv4a7g strong{font-weight:inherit;font-weight:bolder;}.css-hv4a7g h1{font-size:2em;margin:0.67em 0;}.css-hv4a7g img{border-style:none;}.css-hv4a7g code,.css-hv4a7g kbd,.css-hv4a7g pre{font-family:monospace,monospace;font-size:1em;}.css-hv4a7g hr{box-sizing:initial;height:0;overflow:visible;}.css-hv4a7g input{font:inherit;margin:0;}.css-hv4a7g input{overflow:visible;}.css-hv4a7g [type='checkbox']{box-sizing:border-box;padding:0;}.css-hv4a7g *{box-sizing:border-box;}.css-hv4a7g input{font-family:inherit;font-size:inherit;line-height:inherit;}.css-hv4a7g a{color:#0366d6;-webkit-text-decoration:none;text-decoration:none;}.css-hv4a7g a:hover{-webkit-text-decoration:underline;text-decoration:underline;}.css-hv4a7g strong{font-weight:600;}.css-hv4a7g hr{height:0;margin:15px 0;overflow:hidden;background:transparent;border:0;border-bottom:1px solid #dfe2e5;}.css-hv4a7g hr:after,.css-hv4a7g hr:before{display:table;content:'';}.css-hv4a7g hr:after{clear:both;}.css-hv4a7g table{border-spacing:0;border-collapse:collapse;}.css-hv4a7g td,.css-hv4a7g th{padding:0;}.css-hv4a7g details summary{cursor:pointer;}.css-hv4a7g kbd{display:inline-block;padding:3px 5px;font:11px SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;line-height:10px;color:#444d56;vertical-align:middle;background-color:#fafbfc;border:1px solid #d1d5da;border-radius:3px;box-shadow:inset 0 -1px 0 #d1d5da;}.css-hv4a7g h1,.css-hv4a7g h2,.css-hv4a7g h3,.css-hv4a7g h4,.css-hv4a7g h5,.css-hv4a7g h6{margin-top:0;margin-bottom:0;}.css-hv4a7g h1{font-size:32px;}.css-hv4a7g h1,.css-hv4a7g h2{font-weight:600;}.css-hv4a7g h2{font-size:24px;}.css-hv4a7g h3{font-size:20px;}.css-hv4a7g h3,.css-hv4a7g h4{font-weight:600;}.css-hv4a7g h4{font-size:16px;}.css-hv4a7g h5{font-size:14px;}.css-hv4a7g h5,.css-hv4a7g h6{font-weight:600;}.css-hv4a7g h6{font-size:12px;}.css-hv4a7g p{margin-top:0;margin-bottom:10px;}.css-hv4a7g blockquote{margin:0;}.css-hv4a7g ol,.css-hv4a7g ul{padding-left:0;margin-top:0;margin-bottom:0;}.css-hv4a7g ol ol,.css-hv4a7g ul ol{list-style-type:lower-roman;}.css-hv4a7g ol ol ol,.css-hv4a7g ol ul ol,.css-hv4a7g ul ol ol,.css-hv4a7g ul ul ol{list-style-type:lower-alpha;}.css-hv4a7g dd{margin-left:0;}.css-hv4a7g code,.css-hv4a7g pre{font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:12px;}.css-hv4a7g pre{margin-top:0;margin-bottom:0;}.css-hv4a7g input::-webkit-inner-spin-button,.css-hv4a7g input::-webkit-outer-spin-button{margin:0;-webkit-appearance:none;-webkit-appearance:none;-moz-appearance:none;-ms-appearance:none;appearance:none;}.css-hv4a7g hr{border-bottom-color:#eee;}.css-hv4a7g kbd{display:inline-block;padding:3px 5px;font:11px SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;line-height:10px;color:#444d56;vertical-align:middle;background-color:#fafbfc;border:1px solid #d1d5da;border-radius:3px;box-shadow:inset 0 -1px 0 #d1d5da;}.css-hv4a7g a:not([href]){color:inherit;-webkit-text-decoration:none;text-decoration:none;}.css-hv4a7g blockquote,.css-hv4a7g details,.css-hv4a7g dl,.css-hv4a7g ol,.css-hv4a7g p,.css-hv4a7g pre,.css-hv4a7g table,.css-hv4a7g ul{margin-top:0;margin-bottom:16px;}.css-hv4a7g hr{height:0.25em;padding:0;margin:24px 0;background-color:#e1e4e8;border:0;}.css-hv4a7g blockquote{padding:0 1em;color:#6a737d;border-left:0.25em solid #dfe2e5;}.css-hv4a7g blockquote>:first-child{margin-top:0;}.css-hv4a7g blockquote>:last-child{margin-bottom:0;}.css-hv4a7g h1,.css-hv4a7g h2,.css-hv4a7g h3,.css-hv4a7g h4,.css-hv4a7g h5,.css-hv4a7g h6{margin-top:24px;margin-bottom:16px;font-weight:600;line-height:1.25;}.css-hv4a7g h1{font-size:2em;}.css-hv4a7g h1,.css-hv4a7g h2{padding-bottom:0.3em;border-bottom:1px solid #eaecef;}.css-hv4a7g h2{font-size:1.5em;}.css-hv4a7g h3{font-size:1.25em;}.css-hv4a7g h4{font-size:1em;}.css-hv4a7g h5{font-size:0.875em;}.css-hv4a7g h6{font-size:0.85em;color:#6a737d;}.css-hv4a7g ol,.css-hv4a7g ul{padding-left:2em;}.css-hv4a7g ol ol,.css-hv4a7g ol ul,.css-hv4a7g ul ol,.css-hv4a7g ul ul{margin-top:0;margin-bottom:0;}.css-hv4a7g li{word-wrap:break-all;}.css-hv4a7g li>p{margin-top:16px;}.css-hv4a7g li+li{margin-top:0.25em;}.css-hv4a7g dl{padding:0;}.css-hv4a7g dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:600;}.css-hv4a7g dl dd{padding:0 16px;margin-bottom:16px;}.css-hv4a7g table{display:block;width:100%;overflow:auto;}.css-hv4a7g table th{font-weight:600;}.css-hv4a7g table td,.css-hv4a7g table th{padding:6px 13px;border:1px solid #dfe2e5;}.css-hv4a7g table tr{background-color:#fff;border-top:1px solid #c6cbd1;}.css-hv4a7g table tr:nth-child(2n){background-color:#f6f8fa;}.css-hv4a7g img{max-width:100%;box-sizing:initial;}.css-hv4a7g img[align='right']{padding-left:20px;}.css-hv4a7g img[align='left']{padding-right:20px;}.css-hv4a7g code{padding:0.2em 0.4em;margin:0;font-size:85%;background-color:rgba(27, 31, 35, 0.05);border-radius:3px;}.css-hv4a7g pre{word-wrap:normal;padding:16px;overflow:auto;font-size:85%;line-height:1.45;background-color:#f6f8fa;border-radius:3px;}.css-hv4a7g pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;border:0;display:inline;max-width:auto;overflow:visible;line-height:inherit;background-color:initial;}.css-hv4a7g .task-list-item{list-style-type:none;}.css-hv4a7g .task-list-item+.task-list-item{margin-top:3px;}.css-hv4a7g .task-list-item input{margin:0 0.2em 0.25em -1.6em;vertical-align:middle;}.css-11sb6mr{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border-top:1px solid #e1e4e8;padding:16px;min-height:270px;}.css-11sb6mr .utterances{max-width:var(--max-width);}</style></head><body><div id="__next" data-reactroot=""><nav class="css-35tm3r"><a href="/">Found Pan Tiger</a><div class="css-82a6rk"></div><a href="/about">About</a></nav><article class="css-hv4a7g"><h1 id="wasm-输入与输出"><a href="/wasm/%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA#wasm-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA" aria-hidden="true" tabindex="-1"><span></span></a>WASM 输入与输出</h1>
<h2 id="wasm-简介"><a href="/wasm/%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA#wasm-%E7%AE%80%E4%BB%8B" aria-hidden="true" tabindex="-1"><span></span></a>WASM 简介</h2>
<p>WASM（WebAssembly）是一种用于堆栈式虚拟机的二进制指令格式。它是是一种文件格式标准，不是特定的虚拟机实现，因此有各种 compiler、interpreter 以及 runtime，如<a href="https://github.com/bytecodealliance/wasmtime" target="_blank" rel="noreferrer">wastime</a>、<a href="https://wasmer.io/" target="_blank" rel="noreferrer">Wasmer</a>、<a href="https://v8.dev/docs/wasm-compilation-pipeline" target="_blank" rel="noreferrer">V8</a>、 <a href="https://github.com/bytecodealliance/lucet/" target="_blank" rel="noreferrer">Lucet</a>、<a href="https://github.com/bytecodealliance/wasm-micro-runtime" target="_blank" rel="noreferrer">WAMR</a>、<a href="https://github.com/wasm3/wasm3/" target="_blank" rel="noreferrer">wasm3</a>。</p>
<p>WASM 在设计之初，考虑了以下几点：<a href="https://webassembly.org/" target="_blank" rel="noreferrer">🔗</a></p>
<ul>
<li><strong>高效和快速</strong>：体积小，加载速度快。可以流式加载，边下载边初始化，减少时间和内存占用。理论上可以达到原生的运行速度。</li>
<li><strong>安全</strong>：WASM 描述了一个内存安全的沙箱执行环境，甚至可以在现有的 JavaScript 虚拟机中实现。</li>
<li><strong>开放可调试</strong>：可以翻译为可读的文本格式<code>.wat</code>（可以理解为 WASM 平台的汇编语言），配合 source map 方便调试。</li>
<li><strong>Web 标准</strong>：模块能够传入和传出 JavaScript 上下文，并通过 JavaScript 访问 Web API 来访问浏览器功能。同时也<strong>支持非浏览器环境中运行</strong>。</li>
</ul>
<p>但也有以下限制：</p>
<ul>
<li>基础数据类型只有 i32、i64、f32、f64。高级数据结构（如：字符串）每种语言需要自己实现。<a href="https://www.assemblyscript.org/memory.html#internals" target="_blank" rel="noreferrer">🔗</a></li>
<li>只能进行同步计算，不支持异步函数。</li>
<li>对于 Go、Python 这种带运行时的语言编译到 WASM，需要将运行时一起打包，生成的文件体积较大。</li>
</ul>
<p>接下来我们将使用 Node.js（V8）作为 runtime 语言，AssemblyScript 作为编译到 WASM 的语言，来做点实验。</p>
<h2 id="assemblyscript"><a href="/wasm/%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA#assemblyscript" aria-hidden="true" tabindex="-1"><span></span></a>AssemblyScript</h2>
<blockquote>
<p>A language made for WebAssembly.</p>
</blockquote>
<p>对于很多在 WASM 诞生前就已经存在的语言，WASM 就像 x86、ARM64 一样，只是一种新的 platform target。</p>
<p>而 AssemblyScript 是一个为 WASM 而生的语言，目前只能编译到 WASM。它的语法是一种 TypeScript 的变体，但实际写起来时，有时却要像写 C 语言那样思考。</p>
<p>AssemblyScript 项目搭建请参考<a href="https://www.assemblyscript.org/quick-start.html" target="_blank" rel="noreferrer">Quick Start</a>。</p>
<h2 id="ab"><a href="/wasm/%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA#ab" aria-hidden="true" tabindex="-1"><span></span></a>a+b</h2>
<p>我们来写一个简单的 a+b，为什么不是 hello world？因为字符串在 WASM 里是高级数据结构。我们先从最简单的 i32 开始：</p>
<pre><code>// sum.ts
export function sum(a: i32, b: i32): i32 {
  return a + b;
}</code></pre>
<p>编译后得到一个二进制文件<code>sum.wasm</code>，和一个文本文件<code>sum.wat</code>。两者可以使用<a href="https://github.com/WebAssembly/wabt" target="_blank" rel="noreferrer">wabt</a>互相转换。我们以文本格式为例：</p>
<pre><code>; sum.wat
(module
  (type $t0 (func (param i32 i32) (result i32)))
  (func $sum (type $t0) (param $p0 i32) (param $p1 i32) (result i32)
    local.get $p0
    local.get $p1
    i32.add)
  (memory $memory 0)
  (export &quot;sum&quot; (func $sum))
  (export &quot;memory&quot; (memory 0)))</code></pre>
<p>如果学过汇编，不了解 WAT 语法也可以看懂个大概。值得注意的是<code>export &quot;memory&quot;</code>，这是 WSAM 把内存暴露给 runtime，后面的例子会用到。</p>
<p>接下来在 Node.js 中调用：</p>
<pre><code>import fs from &quot;fs&quot;;

const file = await fs.promises.readFile(&quot;./sum.wasm&quot;);
const module = new WebAssembly.Module(file);
const instance = new WebAssembly.Instance(module);

console.log((instance.exports.sum as Function)(1, 2));
// stdout: 3</code></pre>
<p>只需几行代码就完成了调用，并输出了预期的结果。</p>
<h2 id="hello-world"><a href="/wasm/%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA#hello-world" aria-hidden="true" tabindex="-1"><span></span></a>&#x27;hello, world!&#x27;</h2>
<p>来看看字符串是如何在 WASM 与 runtime 之间传递的。</p>
<pre><code>// hello-world.ts
export function hello_world(): string {
  return `hello, world!`;
}</code></pre>
<p>编译后得到：</p>
<pre><code>; hello-world.wat
(module
  (type $t0 (func (result i32)))
  (func $hello_world (type $t0) (result i32)
    i32.const 1056)
  (memory $memory 1)
  (export &quot;hello_world&quot; (func $hello_world))
  (export &quot;memory&quot; (memory 0))
  (data $d0 (i32.const 1036) &quot;,&quot;)
  (data $d1 (i32.const 1048) &quot;\01\00\00\00\1a\00\00\00h\00e\00l\00l\00o\00,\00 \00w\00o\00r\00l\00d\00!&quot;))</code></pre>
<p>在 Node.js 中调用：</p>
<pre><code>import fs from &quot;fs&quot;;

const file = await fs.promises.readFile(&quot;./hello-world.wasm&quot;);
const module = new WebAssembly.Module(file);
const instance = new WebAssembly.Instance(module);

console.log((instance.exports.hello_world as Function)());
// stdout: 1056</code></pre>
<p>结果不是&quot;hello, world!&quot;，而是一个数字，发生什么事了？</p>
<p>这个数字其实是一个指针的地址，它指向了一个字符串。通过<a href="https://www.assemblyscript.org/memory.html#string-layout" target="_blank" rel="noreferrer">string-layout</a>这篇文档，我们可以知道 AssemblyScript 的字符串是如何在内存中排布的，因此我们可以编写代码把字符串取出来。</p>
<pre><code>// ...
const offset = (instance.exports.hello_world as Function)();
const memory = instance.exports.memory as WebAssembly.Memory;
const buffer = Buffer.from(memory.buffer);
const len = buffer.readUInt32LE(offset - 4);

console.log(buffer.slice(offset, offset + len).toString());
// stdout: hello, world!</code></pre>
<p>WASM 使用的是<a href="https://webassembly.github.io/spec/core/syntax/instructions.html#memory-instructions" target="_blank" rel="noreferrer">little endian byte order</a>，因此我们用<code>readUInt32LE</code>而不是<code>readUInt32BE</code>。</p>
<h2 id="hello-str"><a href="/wasm/%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA#hello-str" aria-hidden="true" tabindex="-1"><span></span></a>`hello, ${str}!`</h2>
<p>我们已经学会把字符串从 WASM 传到 runtime 中，接下来我们学习反向操作。</p>
<pre><code>// hello.ts
export function hello(str: string): string {
  return `hello, ${str}!`;
}</code></pre>
<p>使用编译参数：</p>
<pre><code>asc hello.ts --use abort= --target release</code></pre>
<p>我们只改了几个字符，但这次编译出的 hello.wat 已经有 400+行。</p>
<p>在前两个例子中，内存是静态的，而在这个例子里我们进行了字符串拼接，就涉及到了内存的动态管理。因此 AssemblyScript 需要把内存回收运行时打包进 WASM，就增加了文件体积。</p>
<pre><code>// ...
const memory = instance.exports.memory as WebAssembly.Memory;
const buffer = Buffer.from(memory.buffer);
const str = &quot;wasm&quot;;
const ptr = 1024;
buffer.writeUInt32LE(str.length, ptr - 4);
Buffer.from(str).copy(buffer, ptr);
const offset = (instance.exports.hello as Function)(ptr);
const len = buffer.readUInt32LE(offset - 4);

console.log(buffer.slice(offset, offset + len).toString());
// stdout: hello, wasm!</code></pre>
<p>这里的<code>ptr = 1024</code>是一个危险的做法，这个例子里我们假定 WASM 不会使用第 1024 个字节附近的内存，实际使用中不能这么写，这样可能会覆盖掉 WASM 所需要的数据，使 WASM 运行异常。</p>
<p>AssemblyScript 提供了<a href="https://www.assemblyscript.org/loader.html#loader" target="_blank" rel="noreferrer">Loader</a>，封装了这种高级数据结构传递的方法；Rust 也提供了<a href="https://github.com/rustwasm/wasm-bindgen" target="_blank" rel="noreferrer">wasm-bingen</a>，可以生成<code>.js</code>和<code>.d.ts</code>文件，在 js 代码中直接 import 就可以调用 Rust 编写的 WASM 模块中的函数。</p>
<p>到这里，相信你对如何在 WASM 与 runtime 之间传递数据已经有了初步了解。</p></article><footer class="css-15sbtt4">Last modified: <time title="Sun, 26 Jun 2022 12:13:32 GMT">2022-06-26</time></footer><section class="css-11sb6mr"></section><footer class="css-atf797"><span>Generated by: <a href="https://github.com/renzholy/blogit" target="_blank" rel="noreferrer">Blogit</a></span><span class="css-82a6rk"></span><a href="https://github.com/renzholy" target="_blank" rel="noreferrer">GitHub</a><a href="http://twitter.com/aliez_eth" target="_blank" rel="noreferrer">Twitter</a><a href="https://web.okjike.com/u/d25026f2-18ce-48aa-9ea7-c05a25446368" target="_blank" rel="noreferrer">Jike</a></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"lastModified":"Sun, 26 Jun 2022 12:13:32 GMT","data":"# WASM 输入与输出\n\n## WASM 简介\n\nWASM（WebAssembly）是一种用于堆栈式虚拟机的二进制指令格式。它是是一种文件格式标准，不是特定的虚拟机实现，因此有各种 compiler、interpreter 以及 runtime，如[wastime](https://github.com/bytecodealliance/wasmtime)、[Wasmer](https://wasmer.io/)、[V8](https://v8.dev/docs/wasm-compilation-pipeline)、 [Lucet](https://github.com/bytecodealliance/lucet/)、[WAMR](https://github.com/bytecodealliance/wasm-micro-runtime)、[wasm3](https://github.com/wasm3/wasm3/)。\n\nWASM 在设计之初，考虑了以下几点：[🔗](https://webassembly.org/)\n\n- **高效和快速**：体积小，加载速度快。可以流式加载，边下载边初始化，减少时间和内存占用。理论上可以达到原生的运行速度。\n- **安全**：WASM 描述了一个内存安全的沙箱执行环境，甚至可以在现有的 JavaScript 虚拟机中实现。\n- **开放可调试**：可以翻译为可读的文本格式`.wat`（可以理解为 WASM 平台的汇编语言），配合 source map 方便调试。\n- **Web 标准**：模块能够传入和传出 JavaScript 上下文，并通过 JavaScript 访问 Web API 来访问浏览器功能。同时也**支持非浏览器环境中运行**。\n\n但也有以下限制：\n\n- 基础数据类型只有 i32、i64、f32、f64。高级数据结构（如：字符串）每种语言需要自己实现。[🔗](https://www.assemblyscript.org/memory.html#internals)\n- 只能进行同步计算，不支持异步函数。\n- 对于 Go、Python 这种带运行时的语言编译到 WASM，需要将运行时一起打包，生成的文件体积较大。\n\n接下来我们将使用 Node.js（V8）作为 runtime 语言，AssemblyScript 作为编译到 WASM 的语言，来做点实验。\n\n## AssemblyScript\n\n\u003e A language made for WebAssembly.\n\n对于很多在 WASM 诞生前就已经存在的语言，WASM 就像 x86、ARM64 一样，只是一种新的 platform target。\n\n而 AssemblyScript 是一个为 WASM 而生的语言，目前只能编译到 WASM。它的语法是一种 TypeScript 的变体，但实际写起来时，有时却要像写 C 语言那样思考。\n\nAssemblyScript 项目搭建请参考[Quick Start](https://www.assemblyscript.org/quick-start.html)。\n\n## a+b\n\n我们来写一个简单的 a+b，为什么不是 hello world？因为字符串在 WASM 里是高级数据结构。我们先从最简单的 i32 开始：\n\n```typescript\n// sum.ts\nexport function sum(a: i32, b: i32): i32 {\n  return a + b;\n}\n```\n\n编译后得到一个二进制文件`sum.wasm`，和一个文本文件`sum.wat`。两者可以使用[wabt](https://github.com/WebAssembly/wabt)互相转换。我们以文本格式为例：\n\n```clojure\n; sum.wat\n(module\n  (type $t0 (func (param i32 i32) (result i32)))\n  (func $sum (type $t0) (param $p0 i32) (param $p1 i32) (result i32)\n    local.get $p0\n    local.get $p1\n    i32.add)\n  (memory $memory 0)\n  (export \"sum\" (func $sum))\n  (export \"memory\" (memory 0)))\n```\n\n如果学过汇编，不了解 WAT 语法也可以看懂个大概。值得注意的是`export \"memory\"`，这是 WSAM 把内存暴露给 runtime，后面的例子会用到。\n\n接下来在 Node.js 中调用：\n\n```typescript\nimport fs from \"fs\";\n\nconst file = await fs.promises.readFile(\"./sum.wasm\");\nconst module = new WebAssembly.Module(file);\nconst instance = new WebAssembly.Instance(module);\n\nconsole.log((instance.exports.sum as Function)(1, 2));\n// stdout: 3\n```\n\n只需几行代码就完成了调用，并输出了预期的结果。\n\n## 'hello, world!'\n\n来看看字符串是如何在 WASM 与 runtime 之间传递的。\n\n```typescript\n// hello-world.ts\nexport function hello_world(): string {\n  return `hello, world!`;\n}\n```\n\n编译后得到：\n\n```clojure\n; hello-world.wat\n(module\n  (type $t0 (func (result i32)))\n  (func $hello_world (type $t0) (result i32)\n    i32.const 1056)\n  (memory $memory 1)\n  (export \"hello_world\" (func $hello_world))\n  (export \"memory\" (memory 0))\n  (data $d0 (i32.const 1036) \",\")\n  (data $d1 (i32.const 1048) \"\\01\\00\\00\\00\\1a\\00\\00\\00h\\00e\\00l\\00l\\00o\\00,\\00 \\00w\\00o\\00r\\00l\\00d\\00!\"))\n```\n\n在 Node.js 中调用：\n\n```typescript\nimport fs from \"fs\";\n\nconst file = await fs.promises.readFile(\"./hello-world.wasm\");\nconst module = new WebAssembly.Module(file);\nconst instance = new WebAssembly.Instance(module);\n\nconsole.log((instance.exports.hello_world as Function)());\n// stdout: 1056\n```\n\n结果不是\"hello, world!\"，而是一个数字，发生什么事了？\n\n这个数字其实是一个指针的地址，它指向了一个字符串。通过[string-layout](https://www.assemblyscript.org/memory.html#string-layout)这篇文档，我们可以知道 AssemblyScript 的字符串是如何在内存中排布的，因此我们可以编写代码把字符串取出来。\n\n```typescript\n// ...\nconst offset = (instance.exports.hello_world as Function)();\nconst memory = instance.exports.memory as WebAssembly.Memory;\nconst buffer = Buffer.from(memory.buffer);\nconst len = buffer.readUInt32LE(offset - 4);\n\nconsole.log(buffer.slice(offset, offset + len).toString());\n// stdout: hello, world!\n```\n\nWASM 使用的是[little endian byte order](https://webassembly.github.io/spec/core/syntax/instructions.html#memory-instructions)，因此我们用`readUInt32LE`而不是`readUInt32BE`。\n\n## \\`hello, ${str}!\\`\n\n我们已经学会把字符串从 WASM 传到 runtime 中，接下来我们学习反向操作。\n\n```typescript\n// hello.ts\nexport function hello(str: string): string {\n  return `hello, ${str}!`;\n}\n```\n\n使用编译参数：\n\n```bash\nasc hello.ts --use abort= --target release\n```\n\n我们只改了几个字符，但这次编译出的 hello.wat 已经有 400+行。\n\n在前两个例子中，内存是静态的，而在这个例子里我们进行了字符串拼接，就涉及到了内存的动态管理。因此 AssemblyScript 需要把内存回收运行时打包进 WASM，就增加了文件体积。\n\n```typescript\n// ...\nconst memory = instance.exports.memory as WebAssembly.Memory;\nconst buffer = Buffer.from(memory.buffer);\nconst str = \"wasm\";\nconst ptr = 1024;\nbuffer.writeUInt32LE(str.length, ptr - 4);\nBuffer.from(str).copy(buffer, ptr);\nconst offset = (instance.exports.hello as Function)(ptr);\nconst len = buffer.readUInt32LE(offset - 4);\n\nconsole.log(buffer.slice(offset, offset + len).toString());\n// stdout: hello, wasm!\n```\n\n这里的`ptr = 1024`是一个危险的做法，这个例子里我们假定 WASM 不会使用第 1024 个字节附近的内存，实际使用中不能这么写，这样可能会覆盖掉 WASM 所需要的数据，使 WASM 运行异常。\n\nAssemblyScript 提供了[Loader](https://www.assemblyscript.org/loader.html#loader)，封装了这种高级数据结构传递的方法；Rust 也提供了[wasm-bingen](https://github.com/rustwasm/wasm-bindgen)，可以生成`.js`和`.d.ts`文件，在 js 代码中直接 import 就可以调用 Rust 编写的 WASM 模块中的函数。\n\n到这里，相信你对如何在 WASM 与 runtime 之间传递数据已经有了初步了解。\n","pathname":"wasm/输入与输出"},"__N_SSG":true},"page":"/[[...path]]","query":{"path":["wasm","输入与输出"]},"buildId":"XvQqgVKXZyTL6GdtsbpHY","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>