{"pageProps":{"lastModified":"Sun, 26 Jun 2022 12:13:32 GMT","data":"# WASM 输入与输出\n\n## WASM 简介\n\nWASM（WebAssembly）是一种用于堆栈式虚拟机的二进制指令格式。它是是一种文件格式标准，不是特定的虚拟机实现，因此有各种 compiler、interpreter 以及 runtime，如[wastime](https://github.com/bytecodealliance/wasmtime)、[Wasmer](https://wasmer.io/)、[V8](https://v8.dev/docs/wasm-compilation-pipeline)、 [Lucet](https://github.com/bytecodealliance/lucet/)、[WAMR](https://github.com/bytecodealliance/wasm-micro-runtime)、[wasm3](https://github.com/wasm3/wasm3/)。\n\nWASM 在设计之初，考虑了以下几点：[🔗](https://webassembly.org/)\n\n- **高效和快速**：体积小，加载速度快。可以流式加载，边下载边初始化，减少时间和内存占用。理论上可以达到原生的运行速度。\n- **安全**：WASM 描述了一个内存安全的沙箱执行环境，甚至可以在现有的 JavaScript 虚拟机中实现。\n- **开放可调试**：可以翻译为可读的文本格式`.wat`（可以理解为 WASM 平台的汇编语言），配合 source map 方便调试。\n- **Web 标准**：模块能够传入和传出 JavaScript 上下文，并通过 JavaScript 访问 Web API 来访问浏览器功能。同时也**支持非浏览器环境中运行**。\n\n但也有以下限制：\n\n- 基础数据类型只有 i32、i64、f32、f64。高级数据结构（如：字符串）每种语言需要自己实现。[🔗](https://www.assemblyscript.org/memory.html#internals)\n- 只能进行同步计算，不支持异步函数。\n- 对于 Go、Python 这种带运行时的语言编译到 WASM，需要将运行时一起打包，生成的文件体积较大。\n\n接下来我们将使用 Node.js（V8）作为 runtime 语言，AssemblyScript 作为编译到 WASM 的语言，来做点实验。\n\n## AssemblyScript\n\n> A language made for WebAssembly.\n\n对于很多在 WASM 诞生前就已经存在的语言，WASM 就像 x86、ARM64 一样，只是一种新的 platform target。\n\n而 AssemblyScript 是一个为 WASM 而生的语言，目前只能编译到 WASM。它的语法是一种 TypeScript 的变体，但实际写起来时，有时却要像写 C 语言那样思考。\n\nAssemblyScript 项目搭建请参考[Quick Start](https://www.assemblyscript.org/quick-start.html)。\n\n## a+b\n\n我们来写一个简单的 a+b，为什么不是 hello world？因为字符串在 WASM 里是高级数据结构。我们先从最简单的 i32 开始：\n\n```typescript\n// sum.ts\nexport function sum(a: i32, b: i32): i32 {\n  return a + b;\n}\n```\n\n编译后得到一个二进制文件`sum.wasm`，和一个文本文件`sum.wat`。两者可以使用[wabt](https://github.com/WebAssembly/wabt)互相转换。我们以文本格式为例：\n\n```clojure\n; sum.wat\n(module\n  (type $t0 (func (param i32 i32) (result i32)))\n  (func $sum (type $t0) (param $p0 i32) (param $p1 i32) (result i32)\n    local.get $p0\n    local.get $p1\n    i32.add)\n  (memory $memory 0)\n  (export \"sum\" (func $sum))\n  (export \"memory\" (memory 0)))\n```\n\n如果学过汇编，不了解 WAT 语法也可以看懂个大概。值得注意的是`export \"memory\"`，这是 WSAM 把内存暴露给 runtime，后面的例子会用到。\n\n接下来在 Node.js 中调用：\n\n```typescript\nimport fs from \"fs\";\n\nconst file = await fs.promises.readFile(\"./sum.wasm\");\nconst module = new WebAssembly.Module(file);\nconst instance = new WebAssembly.Instance(module);\n\nconsole.log((instance.exports.sum as Function)(1, 2));\n// stdout: 3\n```\n\n只需几行代码就完成了调用，并输出了预期的结果。\n\n## 'hello, world!'\n\n来看看字符串是如何在 WASM 与 runtime 之间传递的。\n\n```typescript\n// hello-world.ts\nexport function hello_world(): string {\n  return `hello, world!`;\n}\n```\n\n编译后得到：\n\n```clojure\n; hello-world.wat\n(module\n  (type $t0 (func (result i32)))\n  (func $hello_world (type $t0) (result i32)\n    i32.const 1056)\n  (memory $memory 1)\n  (export \"hello_world\" (func $hello_world))\n  (export \"memory\" (memory 0))\n  (data $d0 (i32.const 1036) \",\")\n  (data $d1 (i32.const 1048) \"\\01\\00\\00\\00\\1a\\00\\00\\00h\\00e\\00l\\00l\\00o\\00,\\00 \\00w\\00o\\00r\\00l\\00d\\00!\"))\n```\n\n在 Node.js 中调用：\n\n```typescript\nimport fs from \"fs\";\n\nconst file = await fs.promises.readFile(\"./hello-world.wasm\");\nconst module = new WebAssembly.Module(file);\nconst instance = new WebAssembly.Instance(module);\n\nconsole.log((instance.exports.hello_world as Function)());\n// stdout: 1056\n```\n\n结果不是\"hello, world!\"，而是一个数字，发生什么事了？\n\n这个数字其实是一个指针的地址，它指向了一个字符串。通过[string-layout](https://www.assemblyscript.org/memory.html#string-layout)这篇文档，我们可以知道 AssemblyScript 的字符串是如何在内存中排布的，因此我们可以编写代码把字符串取出来。\n\n```typescript\n// ...\nconst offset = (instance.exports.hello_world as Function)();\nconst memory = instance.exports.memory as WebAssembly.Memory;\nconst buffer = Buffer.from(memory.buffer);\nconst len = buffer.readUInt32LE(offset - 4);\n\nconsole.log(buffer.slice(offset, offset + len).toString());\n// stdout: hello, world!\n```\n\nWASM 使用的是[little endian byte order](https://webassembly.github.io/spec/core/syntax/instructions.html#memory-instructions)，因此我们用`readUInt32LE`而不是`readUInt32BE`。\n\n## \\`hello, ${str}!\\`\n\n我们已经学会把字符串从 WASM 传到 runtime 中，接下来我们学习反向操作。\n\n```typescript\n// hello.ts\nexport function hello(str: string): string {\n  return `hello, ${str}!`;\n}\n```\n\n使用编译参数：\n\n```bash\nasc hello.ts --use abort= --target release\n```\n\n我们只改了几个字符，但这次编译出的 hello.wat 已经有 400+行。\n\n在前两个例子中，内存是静态的，而在这个例子里我们进行了字符串拼接，就涉及到了内存的动态管理。因此 AssemblyScript 需要把内存回收运行时打包进 WASM，就增加了文件体积。\n\n```typescript\n// ...\nconst memory = instance.exports.memory as WebAssembly.Memory;\nconst buffer = Buffer.from(memory.buffer);\nconst str = \"wasm\";\nconst ptr = 1024;\nbuffer.writeUInt32LE(str.length, ptr - 4);\nBuffer.from(str).copy(buffer, ptr);\nconst offset = (instance.exports.hello as Function)(ptr);\nconst len = buffer.readUInt32LE(offset - 4);\n\nconsole.log(buffer.slice(offset, offset + len).toString());\n// stdout: hello, wasm!\n```\n\n这里的`ptr = 1024`是一个危险的做法，这个例子里我们假定 WASM 不会使用第 1024 个字节附近的内存，实际使用中不能这么写，这样可能会覆盖掉 WASM 所需要的数据，使 WASM 运行异常。\n\nAssemblyScript 提供了[Loader](https://www.assemblyscript.org/loader.html#loader)，封装了这种高级数据结构传递的方法；Rust 也提供了[wasm-bingen](https://github.com/rustwasm/wasm-bindgen)，可以生成`.js`和`.d.ts`文件，在 js 代码中直接 import 就可以调用 Rust 编写的 WASM 模块中的函数。\n\n到这里，相信你对如何在 WASM 与 runtime 之间传递数据已经有了初步了解。\n","pathname":"wasm/输入与输出"},"__N_SSG":true}